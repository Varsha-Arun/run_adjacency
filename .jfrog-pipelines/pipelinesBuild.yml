pipelines:
  - name: pipelines_build_stg
    configuration:
      environmentVariables:
        readOnly:
          buildPlaneVersion: "1.39.4"
          CHART_VERSION_OVERRIDE: ""
          dockerVersion: "20.10.9"
          dockerComposeVersion: "1.27.4"
          npmRegistry: "https://entplus.jfrog.io/artifactory/api/npm/npm-virtual"
          repo21: "https://entplus.jfrog.io"
          templateTarget: "pipelines-artifacts/template"
          XRAY_ENABLED: "true"
          XRAY_FAIL_PIPELINES: "true"
          CHART_TESTING_IMAGE: releases-docker.jfrog.io/charts-ci
          CHART_TESTING_TAG: 0.1.0
          HELM_VERSION: v3.8.2
          KUBEVAL_VERSION: "0.16.1"
          KUBECTL_VERSION: v1.23.5
          baseMachineImageVersion: "2.4.3"
          SONAR_ENABLED: "{{ ternary false true (or ( hasPrefix "master" "{{gitBranch}}" ) ( hasPrefix "release" "{{gitBranch}}" ) ( hasPrefix "milestone" "{{gitBranch}}" )) }}"
      integrations:
        - name: docker_jfrog_io_reader
        - name: aws_dev_ec2
        - name: entplus_jfrog_io_docker
        - name: entplus_pipelines
        - name: jfdev_agent
        - name: slack_dev_foundation_alerts
        - name: slack_platform_clean_pipeline
        - name: slack_platform_release_pipeline
        - name: jira_jfrog
    steps:
      - name: trigger_controlplane_builds
        type: Bash
        configuration:
          inputResources:
            - name: releasesFile
              <<: *git_resource_trigger_condition
        execution:
          onStart:
            - echo "kicking off all install builds"
            - add_run_variables will_publish_bi="true"

      - name: proto_build
        type: Bash
        configuration:
          affinityGroup: proto
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: protoGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_protoGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - export UPDATE_BUILD_STATUS_PACKAGES_BUILD=false
            - pushd "$res_protoGit_resourcePath"
            - npm ci --no-audit --no-fund --ignore-scripts
            - popd
          onExecute:
            - pushd "$res_protoGit_resourcePath"
            - git checkout {{gitBranch}}
            # nx support affected command that support running command on only changes https://blog.nrwl.io/using-nx-affected-on-ci-d3d2686295a0
            # On development branches run only affected while on master run eveyrthing https://nx.dev/ci/monorepo-ci-gitlab
            # Once those are configured, below logic should be changed
            - npm run generate -w protobuf_schemas/nodepool-service-stub
            - npm run build -w protobuf_schemas/nodepool-service-stub
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: packages_build
        type: Bash
        configuration:
          affinityGroup: packages
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: packagesGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_packagesGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - export UPDATE_BUILD_STATUS_PACKAGES_BUILD=false
            - pushd "$res_packagesGit_resourcePath"
            - npm ci --no-audit --no-fund --ignore-scripts
            - changedFiles=$(git diff-tree --no-commit-id --name-only -r HEAD)
            - |
              if echo "$changedFiles" | grep -i 'packages'; then
                export UPDATE_BUILD_STATUS_PACKAGES_BUILD=true
                echo "Commit contains the changes for packages folder, hence updating the build status for commit"
              else
                echo "Commit doesn't contains the changes for packages folder, hence skipping"
              fi
            - popd
          onExecute:
            - pushd "$res_packagesGit_resourcePath"
            - git checkout {{gitBranch}}
            # nx support affected command that support running command on only changes https://blog.nrwl.io/using-nx-affected-on-ci-d3d2686295a0
            # On development branches run only affected while on master run eveyrthing https://nx.dev/ci/monorepo-ci-gitlab
            # Once those are configured, below logic should be changed
            - npm run build:packages
            #- npx nx affected --base=origin/master --head={{gitBranch}} --target=build 
            - npm run lint:packages
            # - npx nx affected --base=origin/master --head={{gitBranch}} --target=lint
            - npm run test:packages
            # - npx nx affected --base=origin/master --head={{gitBranch}} --target=test
            # Sonar Logic Begin
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - sonar_storeCache packages
            # Sonar Logic End
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: packages_sonar_scan
        type: Bash
        configuration:
          affinityGroup: packages
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: packagesGit
              trigger: false
          inputSteps:
            - name: packages_build
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_packages'
            SONAR_PROJECT_BASE_DIR: './packages'
            SONAR_QUALITYGATE_WAIT: 'false'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_packagesGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: automation_e2e_build
        type: Bash
        configuration:
          environmentVariables:
            JFROG_CLI_BUILD_NAME: "pipelines-automation-e2e"
            JFROG_CLI_BUILD_NUMBER: "${run_id}"
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
          inputResources:
            - name: auto_e2e_gitRepo
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - pushd $res_auto_e2e_gitRepo_resourcePath/
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - source ${res_auto_e2e_gitRepo_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - pushd automation/e2e
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - export e2eImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-automation-e2e"
            - docker build -t $e2eImageName:$RELEASE_VERSION .
            - jfrog rt docker-push $e2eImageName:$RELEASE_VERSION $RT_DOCKER_REPO --build-name="$JFROG_CLI_BUILD_NAME" --build-number="$JFROG_CLI_BUILD_NUMBER"
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: api_build
        type: Bash
        configuration:
          affinityGroup: api
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: apiGit
              <<: *git_resource_trigger_condition
            - name: buildPlaneFS_cp
            - name: ootbExtensionsFS_cp
            - name: node16MicroRunImage
            - name: node16BuildImage
            - name: templateFS
          inputSteps:
            - name: packages_build
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
        execution:
          onStart:
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - source ${res_apiGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_apiGit_resourcePath
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - npm ci --no-audit --no-fund --ignore-scripts
            - npm run build:packages
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export apiImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-api"
          onExecute:
            - pushd $res_apiGit_resourcePath
            - npm run lint -w services/api
            - npm run test -w services/api
            # Sonar Logic Begin
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - sonar_storeCache services/api
            # Sonar Logic End
            - pushd $res_apiGit_resourcePath/services/api
            - mkdir -p bin
            - echo -n $buildPlaneVersion > ./bin/buildplaneVersion.txt
            - echo "Release version is ${RELEASE_VERSION}"
            - ls -atlh ../
            - cp -vr $res_ootbExtensionsFS_cp_resourcePath/extensions-$buildPlaneVersion.tar.gz ./bin/extensions.tar.gz
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-Ubuntu_18.04-$buildPlaneVersion.deb ./bin/buildPlane-x86_64-Ubuntu_18.04.deb
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-Ubuntu_20.04-$buildPlaneVersion.deb ./bin/buildPlane-x86_64-Ubuntu_20.04.deb
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-ARM64-Ubuntu_20.04-$buildPlaneVersion.deb ./bin/buildPlane-ARM64-Ubuntu_20.04.deb
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-CentOS_7-$buildPlaneVersion.rpm ./bin/buildPlane-x86_64-CentOS_7.rpm
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-RHEL_7-$buildPlaneVersion.rpm ./bin/buildPlane-x86_64-RHEL_7.rpm
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-RHEL_8-$buildPlaneVersion.rpm ./bin/buildPlane-x86_64-RHEL_8.rpm
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-WindowsServer_2019-$buildPlaneVersion.tar.gz ./bin/buildPlane-x86_64-WindowsServer_2019.tar.gz
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-MacOS_10.15-$buildPlaneVersion.tar.gz ./bin/buildPlane-x86_64-MacOS_10.15.tar.gz
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-ARM64-MacOS_12-$buildPlaneVersion.tar.gz ./bin/buildPlane-ARM64-MacOS_12.tar.gz
            - cp -vr $res_templateFS_resourcePath/pipelines-template-$RELEASE_VERSION bin/pipelines-template
            - chmod +x bin/pipelines-template
            - |
              RT_SERVER=server \
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              IMG_NAME=$apiImageName \
              PIPELINES_CORE_VERSION=$PIPELINES_CORE_VERSION \
              IMG_TAG=$RELEASE_VERSION \
              MICRO_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag \
              ./buildApi.sh
            - jfrog rt docker-push $apiImageName:$RELEASE_VERSION $RT_DOCKER_REPO --build-name="$JFROG_CLI_BUILD_NAME" --build-number="$JFROG_CLI_BUILD_NUMBER"
            - jfrog rt build-collect-env
            - jfrog rt build-add-git
            - jfrog rt build-publish
            - if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan --project=pipe --fail=${XRAY_FAIL_PIPELINES}; fi
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: api_sonar_scan
        type: Bash
        configuration:
          affinityGroup: api
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: apiGit
              trigger: false
          inputSteps:
            - name: api_build
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_api'
            SONAR_PROJECT_BASE_DIR: './services/api'
            SONAR_QUALITYGATE_WAIT: 'false'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_apiGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: api_clam_scan
        type: Bash
        configuration:
          inputSteps:
            - name: api_build
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-api
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
        {{ end }}
        
      - name: inst_build
        type: Bash
        configuration:
          environmentVariables:
            FORCE_RUN: 'true'
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: installerGit
              <<: *git_resource_trigger_condition
            - name: machineImageJSON_fs
            - name: docker_fs
            - name: dockerCompose_fs
            - name: curl_tar_fs
            - name: curl_rpm_fs
            - name: ootbExtensionsJSONFS
            - name: installerBaseImage
            - name: node16BuildImage
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_installerGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
#            - add_run_variables RT_REPO=$(npm_devArtifactRepoName {{gitBranch}} )
            - add_run_variables RT_REPO="npm-virtual"
            - pushd $res_installerGit_resourcePath/
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - pushd installer
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export installerImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-installer"
            - export nativeBuildName=tar-${JFROG_CLI_BUILD_NAME}
            - debBuildName=deb-${JFROG_CLI_BUILD_NAME}
            - rpmBuildName=rpm-${JFROG_CLI_BUILD_NAME}
          onExecute:
            - pushd $res_installerGit_resourcePath/installer
            - mkdir -p bin dependencies/x86_64/zip/
            - tar zxvf ${res_docker_fs_resourcePath}/docker-${dockerVersion}.tgz -C dependencies/x86_64/zip/
            - cp -vr $res_dockerCompose_fs_resourcePath/installer/docker/docker-compose-${dockerComposeVersion} dependencies/x86_64/bin/
            - mv dependencies/x86_64/bin/docker-compose-${dockerComposeVersion} dependencies/x86_64/bin/docker-compose
            - chmod 555 dependencies/x86_64/bin/docker-compose
            - mv $res_curl_tar_fs_resourcePath/curl/curl/7.74.0/curl-7.74.0.tar.gz dependencies/x86_64/deb/
            - mv $res_curl_rpm_fs_resourcePath/installer/curl/curl-7.29.0-59.el7.x86_64.rpm dependencies/x86_64/yum/
            - export PIPELINES_VERSION=$RELEASE_VERSION
            - echo "Release version is ${RELEASE_VERSION}"
            - dockerTag="$RELEASE_VERSION"
            - tarFilename="pipelines-$RELEASE_VERSION.tar.gz"
            - rpmFilename="pipelines-$RELEASE_VERSION.rpm"
            - debFilename="pipelines-$RELEASE_VERSION.deb"
            - jfrog rt dl --flat pipelines-artifacts/imagebuilds/base-images/${baseMachineImageVersion}-buildplaneImages.json
            - cp -vr ${baseMachineImageVersion}-buildplaneImages.json ./bin/buildplaneImages.json
            - cp -vr $res_ootbExtensionsJSONFS_resourcePath/${buildPlaneVersion}-ootb-extensions.json ./bin/ootb-extensions.json
            - echo $buildPlaneVersion > bin/buildplaneVersion.txt
            - echo $RELEASE_VERSION > bin/controlplaneVersion.txt
            - sudo chmod 1777 /tmp
            - sudo apt-get update --allow-unauthenticated
            - sudo apt-get install -y rsync
            - |
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              RT_REGISTRY=entplus.jfrog.io/${RT_DOCKER_REPO} \
              IMG_NAME=$installerImageName \
              MICRO_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_installerBaseImage_imageName:$res_installerBaseImage_imageTag \
              ./build.sh
            - echo "Generated Artifacts"
            - ls -atlh bin/
            - echo "Successfully built all artifacts"
            - popd
            - pushd $res_installerGit_resourcePath/installer
            - jfrog rt docker-push $installerImageName:$dockerTag $RT_DOCKER_REPO --build-name=${JFROG_CLI_BUILD_NAME} --build-number=${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt upload bin/$tarFilename pipelines-installers/installer/$tarFilename --build-name=${nativeBuildName} --build-number=${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt upload bin/$debFilename deb-snapshot-local/pool/jfrog-pipelines/$debFilename --deb xenial/main/all --build-name=${debBuildName} --build-number=${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt upload bin/$rpmFilename yum-snapshot-local/jfrog-pipelines/$rpmFilename --build-name=${rpmBuildName} --build-number=${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-collect-env ${JFROG_CLI_BUILD_NAME} ${JFROG_CLI_BUILD_NUMBER} #temporary until installer can be moved to native steps
            - jfrog rt build-collect-env ${nativeBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-collect-env ${debBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-collect-env ${rpmBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-add-git ${JFROG_CLI_BUILD_NAME} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-add-git ${nativeBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-add-git ${debBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-add-git ${rpmBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-publish ${JFROG_CLI_BUILD_NAME} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-publish ${nativeBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-publish ${debBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - jfrog rt build-publish ${rpmBuildName} ${JFROG_CLI_BUILD_NUMBER}
            - if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan --project=pipe --fail=${XRAY_FAIL_PIPELINES} ${JFROG_CLI_BUILD_NAME} ${JFROG_CLI_BUILD_NUMBER}; fi
            - if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan --project=pipe --fail=${XRAY_FAIL_PIPELINES} ${debBuildName} ${JFROG_CLI_BUILD_NUMBER}; fi
            - if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan --project=pipe --fail=${XRAY_FAIL_PIPELINES} ${rpmBuildName} ${JFROG_CLI_BUILD_NUMBER}; fi
            - if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan --project=pipe --fail=${XRAY_FAIL_PIPELINES} ${nativeBuildName} ${JFROG_CLI_BUILD_NUMBER}; fi
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
            - echo "Cleaning up stale docker images"
            - docker rmi $(docker images -f "dangling=true" -q) || true
          onComplete:
            - stepCommons_on_complete

      - name: inst_test
        type: Bash
        configuration:
          affinityGroup: installer
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: installerGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: inst_build
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - 14
        execution:
          onStart:
            - source ${res_installerGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_installerGit_resourcePath/installer
            - jfrog rt npm-config --server-id-resolve entplus_deployer --repo-resolve npm-virtual
            - jfrog rt npm-install
            - npm test -- --coverage
            # Sonar Logic Begin
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - sonar_storeCache installer
            # Sonar Logic End
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: inst_sonar_scan
        type: Bash
        configuration:
          affinityGroup: installer
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: installerGit
              trigger: false
          inputSteps:
            - name: inst_test
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_installer'
            SONAR_PROJECT_BASE_DIR: './installer'
            SONAR_QUALITYGATE_WAIT: 'false'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_installerGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: inst_clam_scan
        type: Bash
        configuration:
          inputSteps:
            - name: inst_build
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-installer
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
        {{ end }}
            
      - name: customer_template_build
        type: Bash
        configuration:
          affinityGroup: template
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: templateGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
          outputResources:
            - name: templateFS
          runtime:
            type: image
            image:
              auto:
                language: go
                versions:
                  - {{ .Values.goBuildVersion }}
        execution:
          onStart:
            - source ${res_templateGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_go.sh
            - pushd $res_templateGit_resourcePath
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - pushd template
            - on_start
            - echo "Release version is ${RELEASE_VERSION}"
          onExecute:
            - make install
            - golangci-lint run || true
            - mkdir bin
            - make ARGS="-ldflags \"-X main.version='$RELEASE_VERSION'\"" compile-all
            - jfrog rt upload "bin/templater-${RELEASE_VERSION}-(*)" pipelines-installers/templater/ --target-props "vcs.branch={{gitBranch}};type=go"
            - jfrog rt build-collect-env
            - jfrog rt build-add-git
            - jfrog rt build-publish
            - if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan --project=pipe --fail=${XRAY_FAIL_PIPELINES} ; fi
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: template_build
        type: Bash
        configuration:
          affinityGroup: template
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: templateGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
          outputResources:
            - name: templateFS
          runtime:
            type: image
            image:
              auto:
                language: go
                versions:
                  - {{ .Values.goBuildVersion }}
        execution:
          onStart:
            - source ${res_templateGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_go.sh
            - pushd $res_templateGit_resourcePath
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - pushd template
            - on_start
            - go version
            - echo "Release version is ${RELEASE_VERSION}"
            - make install
            - golangci-lint run || true
            - make test
            - make ARGS="-ldflags \"-X main.version='$RELEASE_VERSION'\"" build
            - BIN_FILENAME="pipelines-template-$RELEASE_VERSION"
            - jfrog rt upload template $templateTarget/$BIN_FILENAME --target-props "vcs.branch={{gitBranch}}"
            - jfrog rt build-collect-env
            - jfrog rt build-add-git
            - jfrog rt build-publish
            - if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan --project=pipe --fail=${XRAY_FAIL_PIPELINES} ; fi
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: template_sonar_scan
        type: Bash
        configuration:
          affinityGroup: template
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
            - name: sonar_jfrog_info
          inputResources:
            - name: templateGit
              trigger: false
          inputSteps:
            - name: template_build
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_template'
            SONAR_PROJECT_BASE_DIR: './template/'
            SONAR_QUALITYGATE_WAIT: 'false'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_templateGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_go.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: micro_build
        type: Bash
        configuration:
          affinityGroup: micro
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
          integrations:
            - name: entplus_deployer
          inputSteps:
            - name: trigger_controlplane_builds
            - name: template_sonar_scan
            - name: packages_build
          inputResources:
            - name: microGit
              <<: *git_resource_trigger_condition
            - name: ootbExtensionsFS_cp
            - name: templateFS
              trigger: false
            - name: node16MicroRunImage
            - name: node16BuildImage
        execution:
          onStart:
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - source ${res_microGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_microGit_resourcePath
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - echo "Release version is ${RELEASE_VERSION}"
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - npm ci --no-audit --no-fund --ignore-scripts
            - npm run build:packages
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export microImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-micro"
          onExecute:
            - pushd $res_microGit_resourcePath
            - npm run lint -w micro
            - npm run test -w micro
            # Sonar Logic Begin
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - sonar_storeCache micro
            # Sonar Logic End
            - pushd $res_microGit_resourcePath/micro
            - mkdir -p bin
            - cp -vr $res_ootbExtensionsFS_cp_resourcePath/extensions-$buildPlaneVersion.tar.gz bin/extensions.tar.gz
            - cp -vr $res_templateFS_resourcePath/pipelines-template-$RELEASE_VERSION bin/pipelines-template
            - chmod +x bin/pipelines-template
            - |
              RT_SERVER=server \
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              IMG_NAME=$microImageName \
              PIPELINES_CORE_VERSION=$PIPELINES_CORE_VERSION \
              IMG_TAG=$RELEASE_VERSION \
              MICRO_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag \
              ./buildMicro.sh
            - jfrog rt docker-push $microImageName:$RELEASE_VERSION $RT_DOCKER_REPO --build-name="$JFROG_CLI_BUILD_NAME" --build-number="$JFROG_CLI_BUILD_NUMBER"
            - jfrog rt build-collect-env
            - jfrog rt build-add-git
            - jfrog rt build-publish
            - if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan --project pipe --fail=${XRAY_FAIL_PIPELINES}; fi
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: microservice_test
        type: Bash
        configuration:
          inputSteps:
            - name: template_build
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: bddGit
              <<: *git_resource_trigger_condition
            - name: templateFS
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - 16
        execution:
          onStart:
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - source ${res_bddGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_bddGit_resourcePath
            - add_run_variables RELEASE_VERSION=$( ./normalizeReleaseVersion.sh {{gitBranch}} )
            - echo "Release version is ${RELEASE_VERSION}"
            - npm ci --no-audit --no-fund --ignore-scripts
            - npm run build:packages
            - npm run build -w tools/ms-testing-library
            - on_start
          onExecute:
            - pushd $res_bddGit_resourcePath
            - cp -vr $res_templateFS_resourcePath/pipelines-template-$RELEASE_VERSION template/template
            - chmod +x template/template
            - npm run lint -w tools/ms-testing-library
            - npm run lint -w bdd
            - npm run build -w tools/ms-testing-library
            - npm run build:micro
            - npm run bdd -w bdd

            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: micro_sonar_scan
        type: Bash
        configuration:
          affinityGroup: micro
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: microGit
              trigger: false
          inputSteps:
            - name: micro_build
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_micro'
            SONAR_PROJECT_BASE_DIR: './micro/'
            SONAR_QUALITYGATE_WAIT: 'false'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_microGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: micro_clam_scan
        type: Bash
        configuration:
          inputSteps:
            - name: micro_build
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-micro
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
      {{ end }}
      
      - name: msg
        type: DockerBuild
        configuration:
          affinityGroup:       msg
          dockerFileLocation:  installer/dependencies/docker/msg
          dockerFileName:      Dockerfile
          dockerImageName:     entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-msg
          dockerImageTag:      ${RELEASE_VERSION}
          environmentVariables:
            SKIP_DOCKER_RESOURCES_CLEANUP: "true"
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
          inputResources:
            - name: msgGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_msgGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_msgGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd installer/dependencies/docker/msg
            - on_start
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: msg_publish
        type: DockerPush
        configuration:
          affinityGroup:        msg
          targetRepository:     ${RT_DOCKER_REPO}
          forceXrayScan:        ${XRAY_ENABLED}
          failOnScan:           ${XRAY_FAIL_PIPELINES}
          autoPublishBuildInfo: true
          integrations:
            - name:             entplus_deployer
            - name:             dockerDotJfrog
          inputSteps:
            - name:             msg
          outputResources:
            - name:             msgBuildInfo

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: msg_clam_scan
        type: Bash
        configuration:
          affinityGroup: msg
          inputSteps:
            - name: msg_publish
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-msg
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
      {{ end }}

      - name: redis
        type: DockerBuild
        configuration:
          affinityGroup:       redis
          dockerFileLocation:  installer/dependencies/docker/redis
          dockerFileName:      Dockerfile
          dockerImageName:     entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-redis
          dockerImageTag:      ${RELEASE_VERSION}
          environmentVariables:
            SKIP_DOCKER_RESOURCES_CLEANUP: "true"
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
          inputResources:
            - name: redisGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_redisGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_redisGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd installer/dependencies/docker/redis
            - on_start
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: redis_publish
        type: DockerPush
        configuration:
          affinityGroup:        redis
          targetRepository:     ${RT_DOCKER_REPO}
          forceXrayScan:        ${XRAY_ENABLED}
          failOnScan:           ${XRAY_FAIL_PIPELINES}
          autoPublishBuildInfo: true
          integrations:
            - name:             entplus_deployer
            - name:             dockerDotJfrog
          inputSteps:
            - name:             redis
          outputResources:
            - name:             redisBuildInfo

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: redis_clam_scan
        type: Bash
        configuration:
          affinityGroup: redis
          inputSteps:
            - name: redis_publish
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-redis
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
      {{ end }}

      - name: observability
        type: DockerBuild
        configuration:
          affinityGroup:       observability
          dockerFileLocation:  installer/dependencies/docker/observability
          dockerFileName:      Dockerfile
          dockerImageName:     entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-observability
          dockerImageTag:      ${RELEASE_VERSION}
          environmentVariables:
            SKIP_DOCKER_RESOURCES_CLEANUP: "true"
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
          inputResources:
            - name: observabilityGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_observabilityGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_observabilityGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd installer/dependencies/docker/observability
            - on_start
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: observability_publish
        type: DockerPush
        configuration:
          affinityGroup:        observability
          targetRepository:     ${RT_DOCKER_REPO}
          forceXrayScan:        ${XRAY_ENABLED}
          failOnScan:           ${XRAY_FAIL_PIPELINES}
          autoPublishBuildInfo: true
          integrations:
            - name:             entplus_deployer
            - name:             dockerDotJfrog
          inputSteps:
            - name:             observability
          outputResources:
            - name:             observabilityBuildInfo

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: observability_clam_scan
        type: Bash
        configuration:
          affinityGroup: observability
          inputSteps:
            - name: observability_publish
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-observability
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
      {{ end }}

      - name: postgres
        type: DockerBuild
        configuration:
          affinityGroup:       postgres
          dockerFileLocation:  installer/dependencies/docker/postgres
          dockerFileName:      Dockerfile
          dockerImageName:     entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-postgres
          dockerImageTag:      ${RELEASE_VERSION}
          environmentVariables:
            SKIP_DOCKER_RESOURCES_CLEANUP: "true"
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
          inputResources:
            - name: postgresGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_postgresGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_postgresGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd installer/dependencies/docker/postgres
            - on_start
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: postgres_publish
        type: DockerPush
        configuration:
          affinityGroup:        postgres
          targetRepository:     ${RT_DOCKER_REPO}
          forceXrayScan:        ${XRAY_ENABLED}
          failOnScan:           ${XRAY_FAIL_PIPELINES}
          autoPublishBuildInfo: true
          integrations:
            - name:             entplus_deployer
            - name:             dockerDotJfrog
          inputSteps:
            - name:             postgres
          inputResources:
            - name:             postgresGit
              <<: *git_resource_trigger_condition
          outputResources:
            - name:             postgresBuildInfo

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: postgres_clam_scan
        type: Bash
        configuration:
          affinityGroup: postgres
          inputSteps:
            - name: postgres_publish
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-postgres
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
      {{ end }}
      
      - name: pipelines_router
        type: DockerBuild
        configuration:
          affinityGroup:       router
          dockerFileLocation:  installer/dependencies/docker/router
          dockerFileName:      Dockerfile
          dockerImageName:     entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-router
          dockerImageTag:      ${RELEASE_VERSION}
          environmentVariables:
            SKIP_DOCKER_RESOURCES_CLEANUP: "true"
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
          inputResources:
            - name: routerGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_routerGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_routerGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd installer/dependencies/docker/router
            - on_start
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: pipelines_router_publish
        type: DockerPush
        configuration:
          affinityGroup:        router
          targetRepository:     ${RT_DOCKER_REPO}
          forceXrayScan:        false
          autoPublishBuildInfo: true
          integrations:
            - name:             entplus_deployer
            - name:             dockerDotJfrog
          inputSteps:
            - name:             pipelines_router
          inputResources:
            - name:             routerGit
              <<: *git_resource_trigger_condition
          outputResources:
            - name:             routerBuildInfo

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: pipelines_router_clam_scan
        type: Bash
        configuration:
          affinityGroup: router
          inputSteps:
            - name: pipelines_router_publish
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-router
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
      {{ end }}

      - name: vault
        type: DockerBuild
        configuration:
          affinityGroup:       vault
          dockerFileLocation:  installer/dependencies/docker/vault
          dockerFileName:      Dockerfile
          dockerImageName:     entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-vault
          dockerImageTag:      ${RELEASE_VERSION}
          environmentVariables:
            SKIP_DOCKER_RESOURCES_CLEANUP: "true"
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
          inputResources:
            - name: vaultGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_vaultGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_vaultGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd installer/dependencies/docker/vault
            - on_start
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: vault_publish
        type: DockerPush
        configuration:
          affinityGroup:        vault
          targetRepository:     ${RT_DOCKER_REPO}
          forceXrayScan:        ${XRAY_ENABLED}
          failOnScan:           ${XRAY_FAIL_PIPELINES}
          autoPublishBuildInfo: true
          integrations:
            - name:             entplus_deployer
          inputSteps:
            - name:             vault
          outputResources:
            - name:             vaultBuildInfo

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: vault_clam_scan
        type: Bash
        configuration:
          affinityGroup: vault
          inputSteps:
            - name: vault_publish
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-vault
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
      {{ end }}

      - name: vault_init
        type: DockerBuild
        configuration:
          affinityGroup:       vault_init
          dockerFileLocation:  installer/dependencies/docker/vault-init
          dockerFileName:      Dockerfile
          dockerImageName:     entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-vault-init
          dockerImageTag:      ${RELEASE_VERSION}
          dockerOptions: --build-arg BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag
          environmentVariables:
            SKIP_DOCKER_RESOURCES_CLEANUP: "true"
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
          inputResources:
            - name: node16MicroRunImage
            - name: vaultInitGit
              <<: *git_resource_trigger_condition
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_vaultInitGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_vaultInitGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_go.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd installer/dependencies/docker/vault-init
            - on_start
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: vault_init_publish
        type: DockerPush
        configuration:
          affinityGroup:        vault_init
          targetRepository:     ${RT_DOCKER_REPO}
          forceXrayScan:        ${XRAY_ENABLED}
          failOnScan:           ${XRAY_FAIL_PIPELINES}
          autoPublishBuildInfo: true
          integrations:
            - name:             entplus_deployer
            - name:             dockerDotJfrog
          inputSteps:
            - name:             vault_init
          inputResources:
            - name: vaultInitGit
              <<: *git_resource_trigger_condition

          outputResources:
            - name:             vaultInitBuildInfo

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: vault_init_clam_scan
        type: Bash
        configuration:
          affinityGroup: vault_init
          inputSteps:
            - name: vault_init_publish
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-vault-init
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
      {{ end }}

      - name: www_build
        type: Bash
        configuration:
          affinityGroup: www
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - "16.10.0"
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: wwwGit
              <<: *git_resource_trigger_condition
            - name: node16MicroRunImage
            - name: node16BuildImage
          inputSteps:
            - name: packages_build
        execution:
          onStart:
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - source ${res_wwwGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_wwwGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - npm ci --no-audit --no-fund --ignore-scripts
            - npm run build:packages
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export wwwImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-www"
          onExecute:
            - pushd $res_wwwGit_resourcePath
            - npm run lint -w services/www
            - npm run test -w services/www
            # Sonar Logic Begin
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - sonar_storeCache services/www
            # Sonar Logic End
            - pushd $res_wwwGit_resourcePath/services/www
            - |
              RT_SERVER=server \
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              IMG_NAME=$wwwImageName \
              IMG_TAG=$RELEASE_VERSION \
              MICRO_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag \
              ./buildWww.sh
            - jfrog rt docker-push $wwwImageName:$RELEASE_VERSION $RT_DOCKER_REPO --build-name="$JFROG_CLI_BUILD_NAME" --build-number="$JFROG_CLI_BUILD_NUMBER"
            - jfrog rt build-collect-env
            - jfrog rt build-add-git
            - jfrog rt build-publish
            - if [ $XRAY_ENABLED = "true" ]; then  jfrog rt build-scan --project=pipe --fail=${XRAY_FAIL_PIPELINES}; fi
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: www_sonar_scan
        type: Bash
        configuration:
          affinityGroup: www
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: wwwGit
              trigger: false
          inputSteps:
            - name: www_build
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_www'
            SONAR_PROJECT_BASE_DIR: './services/www'
            SONAR_QUALITYGATE_WAIT: ${SONAR_ENABLED}
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_wwwGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: www_clam_scan
        type: Bash
        configuration:
          inputSteps:
            - name: www_build
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-www
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
      {{ end }}

      - name: nodePoolService_build
        type: Bash
        configuration:
          affinityGroup: nodePoolService
          runtime:
            type: image
            image:
              custom:
                name: releases-docker.jfrog.io/jfrog/pipelines-u20node
                tag: 16.10.0
                options: '--net=host'
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: nodePoolServiceGit
              <<: *git_resource_trigger_condition
            - name: node16BuildImage
            - name: node16MicroRunImage
          inputSteps:
            - name: packages_build
        execution:
          onStart:
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - source ${res_nodePoolServiceGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_nodePoolServiceGit_resourcePath
            - npm ci --no-audit --no-fund --ignore-scripts
            - npm run build:packages
            - npm run build -w tools/ms-testing-library
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd $res_nodePoolServiceGit_resourcePath/services/nodepool-service
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export nodePoolImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-nodepool-service"
            - export DB_HOST="localhost"
          onExecute:
            - pushd $res_nodePoolServiceGit_resourcePath
            - npm run lint -w services/nodepool-service
            - npm run test -w services/nodepool-service
            - npm run bdd -w services/nodepool-service
            # Sonar Logic Begin
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - sonar_storeCache services/nodepool-service
            # Sonar Logic End
            - pushd $res_nodePoolServiceGit_resourcePath/services/nodepool-service
            - mkdir -p bin
            - echo -n $buildPlaneVersion > ./bin/buildplaneVersion.txt
            - echo "Release version is ${RELEASE_VERSION}"
            - |
              RT_SERVER=server \
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              IMG_NAME=$nodePoolImageName \
              IMG_TAG=$RELEASE_VERSION \
              NODE_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag \
              ./build.sh
            - jfrog rt docker-push $nodePoolImageName:$RELEASE_VERSION $RT_DOCKER_REPO --build-name="$JFROG_CLI_BUILD_NAME" --build-number="$JFROG_CLI_BUILD_NUMBER"
            - jfrog rt build-collect-env
            - jfrog rt build-add-git
            - jfrog rt build-publish
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: nodePoolService_sonar_scan
        type: Bash
        configuration:
          affinityGroup: nodePoolService
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: nodePoolServiceGit
              trigger: false
          inputSteps:
            - name: nodePoolService_build
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_nodepool-service'
            SONAR_PROJECT_BASE_DIR: './services/nodepool-service'
            SONAR_QUALITYGATE_WAIT: ${SONAR_ENABLED}
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_nodePoolServiceGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      {{ if eq true $CLAM_SCAN_ENABLED }}
      - name: nodePoolService_clam_scan
        type: Bash
        configuration:
          inputSteps:
            - name: nodePoolService_build
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-nodepool-service
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd
      {{ end }}

      - name: frontend
        type: DockerBuild
        configuration:
          nodePool:            pipelines_u20
          affinityGroup:       frontend
          dockerFileLocation:  services/frontend
          dockerFileName:      Dockerfile
          dockerImageName:     entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-frontend
          dockerImageTag:      ${RELEASE_VERSION}
          dockerOptions: --build-arg RT_SERVER=entplus_deployer --build-arg RT_URL=${repo21} --build-arg RT_USER=${int_entplus_deployer_user} --build-arg RT_API_KEY=${int_entplus_deployer_apikey} --build-arg BASE_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag
          environmentVariables:
            SKIP_DOCKER_RESOURCES_CLEANUP: "true"
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
          inputResources:
            - name: frontendGit
              <<: *git_resource_trigger_condition
            - name: node16BuildImage
            - name: buildPlaneFS_cp            
          inputSteps:
            - name: trigger_controlplane_builds
        execution:
          onStart:
            - source ${res_frontendGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_frontendGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd services/frontend
            - ls -la
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-Ubuntu_18.04-$buildPlaneVersion.deb buildPlane-x86_64-Ubuntu_18.04.deb
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-Ubuntu_20.04-$buildPlaneVersion.deb buildPlane-x86_64-Ubuntu_20.04.deb
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-WindowsServer_2019-$buildPlaneVersion.tar.gz buildPlane-x86_64-WindowsServer_2019.tar.gz           
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-ARM64-Ubuntu_20.04-$buildPlaneVersion.deb buildPlane-ARM64-Ubuntu_20.04.deb
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-CentOS_7-$buildPlaneVersion.rpm buildPlane-x86_64-CentOS_7.rpm
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-RHEL_7-$buildPlaneVersion.rpm buildPlane-x86_64-RHEL_7.rpm
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-RHEL_8-$buildPlaneVersion.rpm buildPlane-x86_64-RHEL_8.rpm
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-x86_64-MacOS_10.15-$buildPlaneVersion.tar.gz buildPlane-x86_64-MacOS_10.15.tar.gz
            - cp -vr $res_buildPlaneFS_cp_resourcePath/buildPlane-ARM64-MacOS_12-$buildPlaneVersion.tar.gz buildPlane-ARM64-MacOS_12.tar.gz            
            - on_start
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: frontend_publish
        type: DockerPush
        configuration:
          nodePool:             pipelines_u20
          affinityGroup:        frontend
          targetRepository:     ${RT_DOCKER_REPO}
          forceXrayScan:        ${XRAY_ENABLED}
          failOnScan:           ${XRAY_FAIL_PIPELINES}
          autoPublishBuildInfo: true
          integrations:
            - name:             entplus_deployer
            - name:             dockerDotJfrog
          inputSteps:
            - name:             frontend
          inputResources:
            - name: frontendGit
              <<: *git_resource_trigger_condition
          outputResources:
            - name:             frontendBuildInfo

      - name: frontend_sonar_scan
        type: Bash
        configuration:
          nodePool: pipelines_u20
          affinityGroup: frontend
          integrations:
            - name: entplus_deployer
            - name: dockerDotJfrog
            - name: sonar_jfrog_info
          inputResources:
            - name: frontendGit
              trigger: false
          inputSteps:
            - name: frontend_publish
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_ui'
            SONAR_PROJECT_BASE_DIR: './services/frontend/'
            SONAR_QUALITYGATE_WAIT: ${SONAR_ENABLED}
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_frontendGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: stepService_build
        type: Bash
        configuration:
          affinityGroup: stepService
          runtime:
            type: image
            image:
              custom:
                name: releases-docker.jfrog.io/jfrog/pipelines-u20node
                tag: 16.10.0
                options: '--net=host'
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: stepServiceGit
              <<: *git_resource_trigger_condition
            - name: node16BuildImage
            - name: node16MicroRunImage
          inputSteps:
            - name: packages_build
        execution:
          onStart:
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - source ${res_stepServiceGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_stepServiceGit_resourcePath
            - npm ci --no-audit --no-fund --ignore-scripts
            - npm run build:packages
            - npm run build -w tools/ms-testing-library
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd $res_stepServiceGit_resourcePath/services/step-service
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export stepServiceImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-step-service"
          onExecute:
            - pushd $res_stepServiceGit_resourcePath
            - npm run lint -w services/step-service
            - npm run test -w services/step-service
            # - npm run bdd -w services/step-service
            # Sonar Logic Begin
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - sonar_storeCache services/step-service
            # Sonar Logic End
            - pushd $res_stepServiceGit_resourcePath/services/step-service
            - mkdir -p bin
            - echo -n $buildPlaneVersion > ./bin/buildplaneVersion.txt
            - echo "Release version is ${RELEASE_VERSION}"
            - |
              RT_SERVER=server \
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              IMG_NAME=$stepServiceImageName \
              IMG_TAG=$RELEASE_VERSION \
              NODE_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag \
              ./build.sh
            - jfrog rt docker-push $stepServiceImageName:$RELEASE_VERSION $RT_DOCKER_REPO --build-name="$JFROG_CLI_BUILD_NAME" --build-number="$JFROG_CLI_BUILD_NUMBER"
            - jfrog rt build-collect-env
            - jfrog rt build-add-git
            - jfrog rt build-publish
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: runService_build
        type: Bash
        configuration:
          affinityGroup: runService
          runtime:
            type: image
            image:
              custom:
                name: releases-docker.jfrog.io/jfrog/pipelines-u20node
                tag: 16.10.0
                options: '--net=host'
          integrations:
            - name: entplus_deployer
          inputResources:
            - name: runServiceGit
              <<: *git_resource_trigger_condition
            - name: node16BuildImage
            - name: node16MicroRunImage
          inputSteps:
            - name: packages_build
        execution:
          onStart:
            - npm config set registry ${npmRegistry}
            - curl -u"${int_entplus_deployer_user}":"${int_entplus_deployer_apikey}" "${int_entplus_deployer_url}/api/npm/auth" >> ~/.npmrc
            - source ${res_runServiceGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - pushd $res_runServiceGit_resourcePath
            - npm ci --no-audit --no-fund --ignore-scripts
            - npm run build:packages
            #- npm run build -w tools/ms-testing-library
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd $res_runServiceGit_resourcePath/services/run-service
            - on_start
            - add_run_variables BUILD_NUMBER=$JFROG_CLI_BUILD_NUMBER
            - export runServiceImageName="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog/pipelines-run-service"
          onExecute:
            - pushd $res_runServiceGit_resourcePath
            - npm run build:run
            # - npm run lint:run
            - npm run test:run
            # This needs to be enabled once we verify why this is failing
            #- npm run bdd:run
            # Sonar Logic Begin
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - sonar_storeCache services/run-service
            # Sonar Logic End
            - pushd $res_runServiceGit_resourcePath/services/run-service
            - mkdir -p bin
            - echo -n $buildPlaneVersion > ./bin/buildplaneVersion.txt
            - echo "Release version is ${RELEASE_VERSION}"
            - |
              RT_SERVER=server \
              RT_URL=$repo21 \
              RT_USER=$int_entplus_deployer_user \
              RT_API_KEY=$int_entplus_deployer_apikey \
              IMG_NAME=$runServiceImageName \
              IMG_TAG=$RELEASE_VERSION \
              NODE_BUILD_IMAGE=$res_node16BuildImage_imageName:$res_node16BuildImage_imageTag \
              BASE_RUN_IMAGE=$res_node16MicroRunImage_imageName:$res_node16MicroRunImage_imageTag \
              ./build.sh
            - jfrog rt docker-push $runServiceImageName:$RELEASE_VERSION $RT_DOCKER_REPO --build-name="$JFROG_CLI_BUILD_NAME" --build-number="$JFROG_CLI_BUILD_NUMBER"
            - jfrog rt build-collect-env
            - jfrog rt build-add-git
            - jfrog rt build-publish
            - popd
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete
    
      - name: runService_sonar_scan
        type: Bash
        configuration:
          affinityGroup: runService
          integrations:
            - name: entplus_deployer
            - name: sonar_jfrog_info
          inputResources:
            - name: runServiceGit
              trigger: false
          inputSteps:
            - name: runService_build
          environmentVariables:
            SONAR_PROJECT_KEY: 'pipelines_run-service'
            SONAR_PROJECT_BASE_DIR: './services/run-service'
            SONAR_QUALITYGATE_WAIT: 'false'
            RUN_SONAR: 'true'
          runtime:
            type: image
            image:
              custom:
                registry: entplus_deployer
                sourceRepository: docker-staging-local
                name: docker.jfrog.io/sonar-scanner
                tag: ${SONAR_DOCKER_TAG:-latest}
        execution:
          onStart:
            - source ${res_runServiceGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_sonar_npm.sh
            - on_start
          onExecute:
            - on_execute
          onFailure:
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
          onComplete:
            - stepCommons_on_complete

      - name: runService_clam_scan
        type: Bash
        configuration:
          inputSteps:
            - name: runService_build
          inputResources:
            - name: cpGit
              trigger: false
          integrations:
            - name: dockerDotJfrog
          environmentVariables:
            PIPELINES_IMAGE: pipelines-run-service
            APP_PATH: /opt/jfrog/pipelines
        execution:
          onExecute:
            - pushd $res_cpGit_resourcePath/clamAV
            - docker-compose -p ${PIPELINES_IMAGE} -f docker-compose.yaml up --no-build --exit-code-from clamscanner
            - popd

      - name: trigger_post_release
        type: Bash
        configuration:
          inputSteps:
            - name: api_sonar_scan
            - name: packages_sonar_scan
            - name: frontend_sonar_scan
            - name: inst_sonar_scan
            - name: micro_sonar_scan
            - name: nodePoolService_sonar_scan
            - name: runService_sonar_scan
            - name: www_sonar_scan
            - name: pipelines_helm_package
            {{ if eq true $CLAM_SCAN_ENABLED }}
            - name: api_clam_scan
            - name: inst_clam_scan
            - name: micro_clam_scan
            - name: nodePoolService_clam_scan
            - name: runService_clam_scan
            - name: observability_clam_scan
            - name: pipelines_router_clam_scan
            - name: msg_clam_scan
            - name: postgres_clam_scan
            - name: redis_clam_scan
            - name: vault_clam_scan
            - name: vault_init_clam_scan
            - name: www_clam_scan
            {{ else }}
            - name: api_build
            - name: inst_build
            - name: micro_build
            - name: nodePoolService_build
            - name: observability_publish
            - name: pipelines_router_publish
            - name: msg_publish
            - name: postgres_publish
            - name: redis_publish
            - name: vault_publish
            - name: vault_init_publish
            - name: www_build
            - name: runService_build
            {{ end }}
          integrations:
            - name: entplus_deployer
            - name: pipelines_release_notifications
          inputResources:
            - name: cpGit
              trigger: false
          outputResources:
            - name: pipe_rc_wh
            - name: pipelines_release_bitbucket
        execution:
          onStart:
            - source ${res_cpGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/scripts/trigger_post_release_pipeline.sh
            - on_start
          onExecute:
            - on_execute
          onSuccess:
            - |
              if [[ -n $will_publish_bi  ]]
              then
                if [[ {{gitBranch}} = milestone* || {{gitBranch}} = release* ]]
                then
                  set_payload pipe_rc_wh "{\"build_number\":\"$BUILD_NUMBER\",\"step_name\":\"$step_name\",\"version\":\"$RELEASE_VERSION\"}"
                  send_notification pipelines_release_notifications --text "release $RELEASE_VERSION has been built successfully with BuildPlane version ${buildPlaneVersion} and helm chart version ${ChartVersion} "
                fi
              fi
      - name: pipelines_helm_package
        type: Bash
        configuration:
          chronological: true
          integrations:
            - name: pipelines_release_notifications
            - name: entplus_deployer
          inputSteps:
            - name: trigger_controlplane_builds
          inputResources:
            - name: cpGit
              <<: *git_resource_trigger_condition
          outputResources:
            - name: pipelines_helm_build_info
          environmentVariables:
            CHART_TESTING_ARGS: "--charts=helm-charts/stable/pipelines"
            CHART_NAME: "pipelines"
        execution:
          onStart:
            - pushd $res_cpGit_resourcePath
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - BRANCH_SNAPSHOT_VERSION=${RELEASE_VERSION:6}
            - export USERNAME="${int_entplus_deployer_user}"
            - export APIKEY="${int_entplus_deployer_apikey}"
            - source "${res_cpGit_resourcePath}/build/ci/pipelines_step_setup.sh"
            - stepCommons_load_script build/ci/pipelines_package_helm.sh
            - on_start
            - add_run_variables helmRepository=$helmVirtualRepository
          onExecute:
            - on_execute
            - add_run_variables helmChartVersion=${chart_version}-${BRANCH_SNAPSHOT_VERSION}
            - add_run_variables ChartVersion=${BUMP_CHART_VERSION}
          onSuccess:
            - stepCommons_on_success || echo “[ERROR] stepCommons_on_success returned an error”
          onFailure:
            - on_failure || echo “[ERROR] on_failure returned an error”
            - stepCommons_on_failure || echo “[ERROR] stepCommons_on_failure returned an error”
          onComplete:
            - stepCommons_pre_on_complete || echo “[ERROR] stepCommons_pre_on_complete returned an error”
            - on_complete || echo "[ERROR] on_complete returned an error"
            - stepCommons_on_complete || echo “[ERROR] stepCommons_on_complete returned an error”
      - name: create_snapshot_branch
        type: Bash
        configuration:
          inputSteps:
            - name: frontend_sonar_scan
            - name: automation_e2e_build
            - name: microservice_test
            - name: pipelines_helm_package
              status:
                - success
                - failure
                - error
            {{ if eq true $CLAM_SCAN_ENABLED }}
            - name: api_clam_scan
            - name: nodePoolService_clam_scan
            - name: runService_clam_scan
            - name: micro_clam_scan
            - name: www_clam_scan
            - name: inst_clam_scan
            - name: msg_clam_scan
            - name: postgres_clam_scan
            - name: redis_clam_scan
            - name: pipelines_router_clam_scan
            - name: vault_clam_scan
            - name: vault_init_clam_scan
            {{ else }}
            - name: api_build
            - name: nodePoolService_build
            - name: micro_build
            - name: www_build
            - name: inst_build
            - name: msg_publish
            - name: postgres_publish
            - name: redis_publish
            - name: pipelines_router_publish
            - name: vault_publish
            - name: vault_init_publish
            - name: runService_build
            {{ end }}
          integrations:
            - name: entArt
            - name: cpIncomingWebhook
            - name: dockerDotJfrog
          inputResources:
            - name: cpGit
              <<: *git_resource_trigger_condition
          outputResources:
            - name: branchSnapshotBag
          environmentVariables:
            PIPELINES_IMAGE_PREFIX: pipelines-
            DEFAULT_VERSION:
              default: 0.0.0-m000
              description: If branch snapshot image is not present for any services, we will pull images from 0.0.0-m000(master branch) by default. User can change it to any version
        execution:
          onStart:
            - source ${res_cpGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - export IMAGE_NAMES="api automation-e2e frontend installer msg micro nodepool-service observability postgres redis router vault vault-init www run-service"
            - IMAGE_PREFIX="entplus.jfrog.io/${RT_DOCKER_REPO}/jfrog"
            - REGISTRYURL="entplus.jfrog.io/${RT_DOCKER_REPO}"
            - NORMALIZED_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - |
              if [[ "{{gitBranch}}" == release* ]] || [[ "{{gitBranch}}" == milestone* ]] || [[ "{{gitBranch}}" == preRelease* ]] ;  then
                write_output branchSnapshotBag "snapshotVersion=$NORMALIZED_VERSION"
                write_output branchSnapshotBag "registryUrl=$REGISTRYURL"
                exit 0;
              fi
            - pushd $res_cpGit_resourcePath
            - on_start
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - BRANCH_SNAPSHOT_VERSION=${NORMALIZED_VERSION}-${run_number}
            - echo "Snapshot version will be ${BRANCH_SNAPSHOT_VERSION}"
            - |
              if [[ "{{gitBranch}}" == release* ]] || [[ "{{gitBranch}}" == milestone* ]] ; then
                for image in ${IMAGE_NAMES}; do
                  if [[ $(jfrog rt s "${RT_DOCKER_REPO}/jfrog/${PIPELINES_IMAGE_PREFIX}${image}/${NORMALIZED_VERSION}*" | jq length) > 0 ]]; then
                    jfrog rt docker-promote --source-tag ${NORMALIZED_VERSION} --target-tag ${BRANCH_SNAPSHOT_VERSION} --copy=true jfrog/${PIPELINES_IMAGE_PREFIX}${image}  ${RT_DOCKER_REPO} dev-releases-docker-virtual
                  fi
                done
              fi
            - RT_DOCKER_REPO_LOCAL=$(echo "$RT_DOCKER_REPO" | sed "s/virtual/local/")
            - |
              if [[ "{{gitBranch}}" == bugfix* ]] || [[ "{{gitBranch}}" == feature* ]] || [[ "{{gitBranch}}" == master ]] ; then
                for image in ${IMAGE_NAMES}; do
                  if [[ $(jfrog rt s "${RT_DOCKER_REPO}/jfrog/${PIPELINES_IMAGE_PREFIX}${image}/${NORMALIZED_VERSION}*" | jq length) > 0 ]]; then
                    jfrog rt docker-promote --source-tag ${NORMALIZED_VERSION} --target-tag ${BRANCH_SNAPSHOT_VERSION} --copy=true jfrog/${PIPELINES_IMAGE_PREFIX}${image} ${RT_DOCKER_REPO_LOCAL} ${RT_DOCKER_REPO_LOCAL}
                  else
                    jfrog rt docker-promote --source-tag ${DEFAULT_VERSION} --target-tag ${BRANCH_SNAPSHOT_VERSION} --copy=true jfrog/${PIPELINES_IMAGE_PREFIX}${image} dev-master-docker-local ${RT_DOCKER_REPO_LOCAL}
                  fi
                done
              fi
            - write_output branchSnapshotBag "snapshotVersion=$BRANCH_SNAPSHOT_VERSION"
            - committer=$(node automation/tests/committerLoginExtractor.js $res_cpGit_lastAuthorEmail)
            - branchName=$res_cpGit_branchName
            - write_output branchSnapshotBag "committer=$committer"
            - write_output branchSnapshotBag "branchName=$branchName"
            - write_output branchSnapshotBag "registryUrl=$REGISTRYURL"
            - write_output branchSnapshotBag "helmRepo=$helmRepository"
            - write_output branchSnapshotBag "helmChartVersion=$helmChartVersion"
            # TODO: Uncomment this when build nodes have access to versions.jfrog.info
            # - |
            #   if [[ -z "$CHART_VERSION_OVERRIDE" ]]
            #   then
            #       echo "using chart from newest available release"
            #       CHART_VERSION=10$(curl -s "https://versions.jfrog.info/latestVersions?products=pipelines" | jq -r '.pipelines.release')
            #       write_output branchSnapshotBag "chartVersion=$CHART_VERSION"
            #   else
            #       echo "using chart version $CHART_VERSION_OVERRIDE"
            #       write_output branchSnapshotBag "chartVersion=$CHART_VERSION_OVERRIDE"
            #   fi
            - |
              echo "Checking if commit $res_cpGit_commitSha exists"
              if [ "$(git cat-file -t $res_cpGit_commitSha)" != "commit" ]; then
                write_output branchSnapshotBag "onlyAutomationChange=false"
                exit 0
              fi
            - |
              echo "Checking if commit $res_cpGit_beforeCommitSha exists"
              if [ "$(git cat-file -t $res_cpGit_beforeCommitSha)" != "commit" ]; then
                write_output branchSnapshotBag "onlyAutomationChange=false"
                exit 0
              fi
            - |
              if [ $(git diff --name-only $res_cpGit_beforeCommitSha $res_cpGit_commitSha | grep -v "automation/tests/" | wc -l) -gt 0 ]; then
                echo "something other than automation folder has changed"
                write_output branchSnapshotBag "onlyAutomationChange=false"
              else
                echo "only automation folder changed"
                write_output branchSnapshotBag "onlyAutomationChange=true"
              fi
          onComplete:
            - stepCommons_on_complete
          onFailure:
            - echo "Images are missing for this branch build! Trigger pipelines to build"
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
  - name: pipelines_frontend_unit_test
    steps:
      - name: frontend_unit_test
        type: Bash
        configuration:
          nodePool: pipelines_u20
          inputResources:
            - name: frontendGit
              trigger: false
          integrations:
            - name: entplus_deployer
            - name: entplus_jfrog_io_docker
            - name: dockerDotJfrog
          runtime:
            type: image
            image:
              auto:
                language: node
                versions:
                  - 16
        execution:
          onStart:
            - source ${res_frontendGit_resourcePath}/build/ci/pipelines_step_setup.sh
            - pushd $res_frontendGit_resourcePath
            - add_run_variables RELEASE_VERSION=$(./normalizeReleaseVersion.sh {{gitBranch}})
            - stepCommons_load_script build/ci/pipelines_build_npm.sh
            - stepCommons_load_script build/ci/pipelines_build_docker.sh
            - add_run_variables RT_DOCKER_REPO=$(docker_devArtifactRepoName {{gitBranch}} )
            - pushd services/frontend
            - on_start
          onExecute:
            - jfrog rt npm-config --server-id-resolve entplus_deployer --repo-resolve npm-virtual
            - jfrog rt npm-install --legacy-peer-deps
            - npm run build
            - npm run test
          onFailure:
            - update_commit_status frontendGit
            - stepCommons_on_failure
          onSuccess:
            - stepCommons_on_success
            - update_commit_status frontendGit
          onComplete:
            - stepCommons_on_complete
            - update_commit_status frontendGit
